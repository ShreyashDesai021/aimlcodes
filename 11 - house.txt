
# Imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error

DATA_PATH = "Synthetic_House_Price_Dataset.csv"


# Load
df = pd.read_csv(DATA_PATH)

# Keep only required columns
df.columns = [c.strip().lower() for c in df.columns]
req = ['area','bedrooms','location','price']
missing = [c for c in req if c not in df.columns]
if missing:
    raise ValueError(f"Dataset must contain columns: {req}. Missing: {missing}")

df = df[req].copy()

# Drop missing and ensure numeric types
df = df.dropna(subset=req).reset_index(drop=True)
df['area'] = pd.to_numeric(df['area'], errors='coerce')
df['bedrooms'] = pd.to_numeric(df['bedrooms'], errors='coerce')
df['price'] = pd.to_numeric(df['price'], errors='coerce')
df = df.dropna(subset=['area','bedrooms','price']).reset_index(drop=True)

print(df.shape)
df.head()


# Price distribution
plt.figure()
df['price'].hist(bins=30)
plt.title("Price Distribution")
plt.xlabel("Price")
plt.ylabel("Count")
plt.show()



# Area vs Price scatter
plt.figure()
plt.scatter(df['area'], df['price'], alpha=0.6)
plt.plot(np.unique(df['area']), np.poly1d(np.polyfit(df['area'], df['price'], 1))(np.unique(df['area'])), color='red') 
plt.title("Area vs Price")
plt.xlabel("Area")
plt.ylabel("Price")
plt.show()


X = df[['area','bedrooms','location']].copy()
y = df['price'].values

# Function to split data into k folds
def make_folds(n_rows, k=5):
    index = np.arange(n_rows)
    np.random.shuffle(index)
    fold_size = n_rows // k
    folds = []
    for i in range(k):
        test_idx = index[i*fold_size:(i+1)*fold_size]
        train_idx = np.setdiff1d(index, test_idx)
        folds.append((train_idx, test_idx))
    return folds

# Function to calculate RMSE
def calc_rmse(y_true, y_pred):
    return np.sqrt(mean_squared_error(y_true, y_pred))

# Create 5 folds
folds = make_folds(len(X), k=5)

results = []

for i, (train_idx, test_idx) in enumerate(folds, 1):
    # Split train/test
    X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
    y_train, y_test = y[train_idx], y[test_idx]

    # Encode and scale
    enc = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
    sc = StandardScaler()

    X_train_enc = np.concatenate([sc.fit_transform(X_train[['area','bedrooms']]),
                                  enc.fit_transform(X_train[['location']])], axis=1)
    X_test_enc  = np.concatenate([sc.transform(X_test[['area','bedrooms']]),
                                  enc.transform(X_test[['location']])], axis=1)

    # Train model
    model = LinearRegression()
    model.fit(X_train_enc, y_train)

    # Predict
    y_pred = model.predict(X_test_enc)

    # Store metrics
    results.append({
        'Fold': i,
        'R2': r2_score(y_test, y_pred),
        'RMSE': calc_rmse(y_test, y_pred),
        'MAE': mean_absolute_error(y_test, y_pred)
    })

# Display results
cv_results = pd.DataFrame(results)
print("Per Fold Results:\n", cv_results)
print("\nAverage Scores:\n", cv_results.mean(numeric_only=True))

# ----- Final Linear Regression Model on Full Data -----

# Encode and scale the whole dataset
enc = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
sc = StandardScaler()

X_cat = enc.fit_transform(X[['location']])
X_num = sc.fit_transform(X[['area', 'bedrooms']])
X_final = np.concatenate([X_num, X_cat], axis=1)

# Train linear regression on full data
model = LinearRegression()
model.fit(X_final, y)

# Get feature names
num_cols = ['area', 'bedrooms']
cat_cols = list(enc.get_feature_names_out(['location']))
all_features = num_cols + cat_cols

# Create dataframe for coefficients
coef_table = pd.DataFrame({
    'Feature': all_features,
    'Coefficient': model.coef_
}).sort_values(by='Coefficient', ascending=False).reset_index(drop=True)

# Display results
print("Model Intercept:", model.intercept_)
print("\nTop Coefficients:\n")
print(coef_table.head(10))

# Predicted vs Actual with fixed colors
y_pred_full = model.predict(X_final)


plt.scatter(y, y_pred_full, alpha=0.6, color='blue')  # fixed blue points
p = np.poly1d(np.polyfit(y, y_pred_full, 1))
plt.plot(np.sort(y), p(np.sort(y)), color='red')      # red best-fit line

plt.title("Predicted vs Actual (Full Model)")
plt.xlabel("Actual Price")
plt.ylabel("Predicted Price")
plt.show()
